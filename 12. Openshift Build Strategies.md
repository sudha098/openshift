## ğŸ—ï¸ OpenShift Build Strategies

OpenShift provides multiple build strategies to create container images from application source code.
Each strategy suits different workflows such as Docker-based builds, Source-to-Image (S2I), custom build logic, or CI pipelines.

---

### ğŸ”¹ 1ï¸âƒ£ Source-to-Image (S2I)

> Best for building applications **without writing Dockerfiles**

**How it works**

* Takes application **source code**
* Injects it into a **builder image**
* Produces a runtime image automatically

| Pros                                   | Cons                                    |
| -------------------------------------- | --------------------------------------- |
| No Dockerfile required                 | Less flexibility for custom build steps |
| Automatic rebuild when builder changes | Relies on builder image capabilities    |
| Fast, secure, opinionated              | Limited in highly-customized scenarios  |

Example snippet:

```yaml
strategy:
  sourceStrategy:
    from:
      kind: ImageStreamTag
      name: python:3.9
```

---

### ğŸ”¹ 2ï¸âƒ£ Docker Build Strategy

> Uses your **Dockerfile** for building the image

| Pros                                     | Cons                                            |
| ---------------------------------------- | ----------------------------------------------- |
| Maximum flexibility                      | You must manage security, patches in Dockerfile |
| Compatible with most container workflows | Sensitive content may leak during build         |

Example:

```yaml
strategy:
  dockerStrategy: {}
```

---

### ğŸ”¹ 3ï¸âƒ£ Custom Build Strategy

> Bring your own build tooling inside a **custom builder image**

Good for:

* Legacy apps
* Specialized compilers / build environments
* Running proprietary build scripts

Example:

```yaml
strategy:
  customStrategy:
    from:
      kind: ImageStreamTag
      name: custom-builder:latest
```

âš ï¸ Security responsibility is on the user because **privileged containers** may be required.

---

### ğŸ”¹ 4ï¸âƒ£ Pipeline Build Strategy

> Build using **Tekton Pipelines** (CI/CD as code)

Features:

* YAML-defined pipeline tasks
* Full CI workflows (tests, scans, approvals)
* GitOps-friendly automation

Example:

```yaml
strategy:
  jenkinsPipelineStrategy:
    jenkinsfilePath: Jenkinsfile
```

(Older clusters use Jenkins Pipelines â€” newer OpenShift uses **Tekton**)

---

### ğŸ“Œ Strategy Comparison

| Feature                |    S2I   |    Docker    |    Custom   |   Pipeline   |
| ---------------------- | :------: | :----------: | :---------: | :----------: |
| Handles Dockerfile     |     âŒ    |       âœ…      | ğŸ” Optional |       âŒ      |
| Secure build sandbox   |     âœ…    | âš ï¸ Sometimes |      âŒ      |       âœ…      |
| Best for enterprise CI |    âœ”ï¸    |      âœ”ï¸      |      âš ï¸     |    â­ Best    |
| Developer experience   |  â­ Easy  |    Medium    |     Hard    |    Medium    |
| Automatic rebuilds     | Built-in | Configurable |   Depends   | Configurable |

---

### ğŸ§² How OpenShift chooses the strategy?

OpenShift inspects the source:

* If a Dockerfile exists â†’ **Docker strategy**
* If builder ImageStream provided â†’ **S2I**
* If BuildConfig specifies custom â†’ **Custom**
* If Jenkinsfile/pipeline defined â†’ **Pipeline**

---

## ğŸ“Œ Common Commands

Start a build manually:

```sh
oc start-build my-app
```

Check build logs:

```sh
oc logs -f build/my-app-1
```

View build strategies for all BCs:

```sh
oc get bc -o wide
```

---

## ğŸ§  Summary

| Strategy | Best for                                   |
| -------- | ------------------------------------------ |
| S2I      | Fast build & deploy for common languages   |
| Docker   | Full control of container build            |
| Custom   | Highly customized legacy environments      |
| Pipeline | Enterprise CI/CD with multi-step workflows |

---

## ğŸ“¥ Build Input (Source Types in OpenShift Builds)

Builds in OpenShift can take input from multiple sources to generate a container image.
This gives flexibility for different CI/CD workflows â€” whether you build from Git, local binaries, Dockerfiles, or existing images.

---

### ğŸ”¹ 1ï¸âƒ£ Git Repository (Most Common)

The build pulls **source code directly from a Git repo**.

```yaml
source:
  type: Git
  git:
    uri: https://github.com/org/demo-app.git
    ref: main
```

Supports:

* GitHub
* GitLab
* Bitbucket
* Private repos via SSH credentials or token secrets

---

### ğŸ”¹ 2ï¸âƒ£ Binary (Local Artifact Upload)

Trigger a build using **locally compiled artifacts**, not a code repository.

Example:

```sh
oc start-build demo-app --from-file=app.jar
```

Useful when:

* Build happens in external CI like Jenkins/GitHub Actions
* Artifact is already compiled
* Internal source code cannot leave the company network

---

### ğŸ”¹ 3ï¸âƒ£ Dockerfile (Inline or From Repo)

Use a **Dockerfile inside the repo** or **inline in BuildConfig**.

**Inline Dockerfile example:**

```yaml
source:
  type: Dockerfile
  dockerfile: |
    FROM registry.access.redhat.com/ubi8
    COPY . /opt/app
```

If both **Dockerfile + source code** exist â†’ OpenShift automatically uses **Docker Build strategy**.

---

### ğŸ”¹ 4ï¸âƒ£ Image (Image Source)

Pulls artifacts from an **existing image** and reuses them in the build.

```yaml
source:
  type: Image
  images:
    - from:
        kind: ImageStreamTag
        name: java-builder:latest
      paths:
        - sourcePath: /output
          destinationDir: /opt/app
```

Useful for:

* Multi-stage builds
* Framework-generated artifacts
* Builder â†’ runtime split builds

---

### ğŸ”¹ 5ï¸âƒ£ Multi-source Inputs (Combined Sources)

Builds can combine **Git + Binary + Dockerfile + Image** inputs.

Example:

```yaml
source:
  type: Git
  git:
    uri: https://github.com/org/demo.git
  contextDir: ./src
  binary: {}
```

---

## ğŸ” Additional Build Input Enhancements

| Feature                     | Purpose                               |
| --------------------------- | ------------------------------------- |
| Webhooks                    | Trigger build from GitHub/GitLab push |
| Secrets                     | Access private repo credentials       |
| ConfigMaps                  | Inject config files during build      |
| Build environment variables | Add build-time app settings           |

Example secret for private repo:

```yaml
sourceSecret:
  name: git-repo-ssh-key
```

---

## ğŸ§  When to use which input?

| Use Case                           | Best Input Type |
| ---------------------------------- | --------------- |
| Normal build from code             | Git             |
| CI server creates artifact         | Binary          |
| Need full Docker flexibility       | Dockerfile      |
| Reuse generated binaries or layers | Image           |
| Hybrid build (complex cases)       | Multi-source    |

---

## ğŸ“Œ Build Input â†’ Build Strategy Matrix

| Input Type | S2I | Docker | Custom | Pipeline |
| ---------- | :-: | :----: | :----: | :------: |
| Git        |  âœ…  |    âœ…   |   âš ï¸   |    âš ï¸    |
| Binary     |  âš ï¸ |   âš ï¸   |   âš ï¸   |    âš ï¸    |
| Dockerfile |  âŒ  |    âœ…   |    âŒ   |     âŒ    |
| Image      |  âš ï¸ |   âš ï¸   |   âš ï¸   |     âŒ    |

ğŸ”¹ = usable
âš ï¸ = depends on BuildConfig design

---

## ğŸ” Full BuildConfig Input Example (Git + Dockerfile + Secrets)

```yaml
source:
  type: Git
  git:
    uri: https://github.com/org/my-app.git
    ref: main
  contextDir: app
  dockerfile: |
    FROM node:18
    COPY . /app
    RUN npm install

sourceSecret:
  name: github-deploy-key
```

---


